###### tags: `learn`

# 八股万般

## 1. 计网

### 网络分层（五层，七层）

TCP/IP五层模型：
![](https://i.imgur.com/8pvN1sS.png)

> 七层模型是将应用层分为：
    > - 应用层
    > - 表示层
    > - 会话层

![](https://i.imgur.com/4uNvdWv.png)

---

### 三握四挥

**三握：**
![](https://i.imgur.com/kveVZFi.png)
> 为什么三握？
> 1. TCP并非固定信道通信，第一次握手服务器确认可以收到客户端报文，而二次握手时客户端也确认了可以收到服务器报文，但是服务器却不知道自己报文能否传达！
> 2. 因此，二次握手之后的服务器处于半连接状态，缓存一定资源待第三次握手后传输；如果这个时候客户端没有回应了，就会造成资源浪费；若多个客户端都无第三次握手，则会由于资源被占满而使服务器功能受阻（dos攻击）。

**四挥：**
![](https://i.imgur.com/Fuk1QHi.png)
> 首先，四次挥手是客户端与服务器进行双方的确认。
> 其次，客户端向服务器发起断开连接请求时，也带有部分资源请求；服务器收到报文时进入 CLOSE_WAIT状态，先发送断开请求的确认，再发送剩余的报文且由服务器端发出FIN的请求，最后由客户端确认请求，四次挥手断开连接。
> 问题就在于，如果服务器端的第二三次合并的话，服务器会先发送剩余报文并在最后一次即LAST_ACK时发送断开连接的ACK，这中间会有较长的时间，导致客户端判定超时从而反复发送FIN请求，导致资源的浪费。

:::success
为什么SYN和FIN不包含数据却要消耗一个序列号？

只需记住，凡是需要对端确认的，一定消耗TCP报文的序列号！
:::

---

### TCP快速打开（TFO, TCP Fast Open）

TFO：对于已经三握对象，可以在发送第一个SYN包时候就开始传数据！
快速打开的两个阶段：
1. Fast Open Cookie;
2. TCP Fast Open

![](https://i.imgur.com/fjDOhPp.png)


> 优势：可以利用握手去除一个往返RTT，防范SYN洪泛攻击。

---

### TCP报文相关

![](https://i.imgur.com/kMEXWKX.png)

**时间戳**：
1. 计算发送&往返时延RTT
2. 防止序列号回绕问题！（TCP序列号用32bit表示，最大到2^32字节传输后序列号就会溢出而重复使用）

**端口号**：
1. 端口号用2字节表示，最大为2^16=65536
2. 不同进程使用不同的端口号进行端到端连接

:::info
**窗口大小**
**流量控制：通过接收端缓存区的大小，控制发送报文的速率。**

如果接收端窗缓存区满了，则发送很小的一个报文（不能不发，不发就断了连接了啊）
:::

---

### TCP超时重传如何计算/设计？

对于RTT波动小的情况，最经典的就是取多次RTT平均值，但是为了做到平滑，会降低新的RTT权重（α，取0.8~0.9）即： `new RTT = α*PreAveRTT + (1-α)*lastRTT`
> 也就是，新的RTT等于 80%的初始值 + 20%的新采样的RTT值。

---

### TCP的keep alive（检测长时间死连接）
**死连接**
![](https://i.imgur.com/LV6WcPf.png)

keepalive机制：定时发送探测包探测对端是否存活。（但是TCP默认设置为7200s，过长，所以其实大多这种设置都创建在应用层。）

---

### 收到报文时如何确认是TDP还是UDP？

网络层的Ip头里面有一栏 **协议**， 若协议字段为6则为TCP，若为17则为UDP（ICMP为1）。

---

### 各个模块

1. telnet：检查一个端口是否打开
2. netstat：显示各种网络相关信息
3. tcpdump：命令行的抓包工具
4. wireshark：windows端的一个网络抓包工具

---
:::danger
:::

---
# 操作系统

操作系统的两个基本特征：并发，共享

## 内核

**“内核”指的是一个提供硬件抽象层、磁盘及文件系统控制、多任务等功能的系统软件**
- 内核态：运行操作系统程序，几乎可以访问计算机的任何（硬件）资源
- 用户态：运行用户应用程序

---

## 进程&线程

进程（Process） 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。

进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。通俗点讲，进程是一段程序的执行过程，是个动态概念。

:::info
**僵尸进程**

僵尸进程 是子进程先于父进程退出后，子进程的 PCB (进程控制块) 需要其父进程释放，但是父进程并没有释放子进程的 PCB，这样的子进程就称为僵尸进程。
**僵尸进程实际上是一个已经死掉但并未释放 PCB 的进程**。

--
**如何避免僵尸进程**

1. 父进程通过wait和waitpid等函数等待子进程结束；

2. 父进程不关心子进程的结束，则交给内核处理；

3. 使用signal函数为SIGCHLD安装handler；

4. fork两次，回收子进程，并将孙进程交给１号进程（initi进程）。

---

**孤儿进程**

一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。

孤儿进程将被 init 进程（pid=1）所收养，并由init进程对它们完成状态收集工作。

和僵尸进程的差别：孤儿进程不占用资源！因为它终究是被系统回收了。不会像僵尸进程那样占用 ID，损害运行系统。
:::

:::success
**进程和线程的区别？**

* 进程是资源分配的最小单位，线程是CPU调度的最小单位
* 进程有自己的独立地址空间，线程共享地址空间
* 多进程程序更健壮，一个进程不会对其他进程造成影响
* 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据
* 进程上下文切换开销大，线程开销小
:::

:::warning
**什么是协程？**

协程是用户态的轻量级线程，是一种比线程更加轻量级的存在，协程不被操作系统内核管理，完全由程序控制。

协程的优点

1）没有线程切换开销；

2）单线程无需对共享资源加锁机制。

其缺点也显而易见，就是无法利用多核资源。协程本质还是单线程，无法直接利用多核处理器，需要配合进程实现。
:::

:::success
**进程有哪些调度算法**？

调度算法是指根据系统的资源分配策略所规定的资源分配算法。

* 先来先服务（FCFS）
* 短作业优先（SJF）
* 时间片轮转（RR）
* 优先级调度
:::

:::info
**进程间有哪些通信方式**？

1）管道 2）信号量（计数器） 3）信号（事件）

4）消息队列 5）共享内存 6）本地套接字

**优劣**？
- 管道：管道单向，所以需要创建两个；并且管道通信方式效率低，不适合进程间频繁地交换数据；实质像队列，遵循FIFO，无法插队；优点就是简单。**所谓的管道，就是内核里面的一串缓存。**

    管道分为「匿名管道」和「命名管道」。

    匿名管道顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「|」竖线就是匿名管道，通信的数据是无格式的流并且大小受限，通信的方式是单向的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来匿名管道是只能用于存在父子关系的进程间通信，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。

    命名管道突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不支持 lseek 之类的文件定位操作。
    
- 消息队列：**消息队列是保存在内核中的消息链表**，不适合比较大数据的传输，因为每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。
- 共享内存：共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。但是！如果多个进程同时修改同一个共享内存，很有可能就冲突了。
- 信号量：信号量其实是一个整型的计数器，信号量不仅可以实现访问的互斥性，还可以实现进程间的同步；它保证了共享的资源，在任意时刻只能被一个进程访问。
- 信号：**对于异常情况下的工作模式，就需要用「信号」的方式来通知进程**。==信号是进程间通信机制中唯一的异步通信机制==。一旦有信号发生，进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号。
- Socket：想跨网络与不同主机上的进程之间通信，就需要 Socket 通信。


---
**线程间的通信方式**？

1）互斥量 2）信号量 3）事件
:::

:::danger
* 死锁：互相等待对方手里的资源，导致各个进程都阻塞，都无法向前推进的现象
* 饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。
* 死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致，有时是程序员刻意为之

**死锁的解决方案**

1. 预防死锁：破坏四大条件（互斥，不剥夺，请求与保持，循环等待条件）

2. 避免死锁：银行家算法

3. 检测死锁：利用死锁定理：若资源分配图不是可以完全简化的，则说明发生了死锁

4. 解除死锁：进程回退，撤销进程，剥夺资源.

**银行家算法**：

核心思想：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态，如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等等
:::

---

## 内存

- 虚拟地址：指由程序产生的与段相关的偏移地址；虚拟内存是操作系统提供的一种内存管理技术，使得程序认为拥有连续可用的内存空间，而实际被分配到不同的物理内存碎片中。

- 物理地址：指加载到内存地址寄存器中的地址，内存单元的真正地址。

:::success
**内存管理机制**：

内存管理可以简单的分为连续分配管理方式和非连续分配管理方式这两种。

连续分配管理方式是指为一个用户程序分配一个连续的内存空间，比如块式管理。非连续分配管理方式允许一个程序内存分散，比如页式管理、段式管理和段页式管理。

* 块式管理： 远古时代的计算机操作系统的内存管理方式，将内存分为几个固定大小的块，每个块只包含一个进程，如果程序运行需要内存，操作系统就给它分配一块，如果程序运行只需要很小的空间，则分配的这块内存很大一部分就浪费了，这些在每个块中未被利用的空间，我们称为碎片。
* 页式管理： 把主存分为大小相等且固定的一页一页的形式，页比较小，相对于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。
* 段式管理： 页式管理虽然提高了内存利用率，但是其中的页没有任何实际意义，段式管理把主存分为一段一段 ，每一段的空间又比一页的空间小很多。但是段有实际意义，段式管理通过段表对应逻辑地址和物理地址。
* 段页式管理： 段页式管理机制结合了段式管理和页式管理的优点，就是把主存分为若干段，每个段又分为若干页，也就是说段页式管理机制中段和段之间以及段的内部都是离散的。
:::
